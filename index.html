<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Voice Silk</title>
  <style>
    :root{
      --txt:#0d1020;
      --sub:#2a2f46;
    }
    html,body{margin:0;height:100%;overflow:hidden;background:#f4f6ff;}
    canvas{display:block;width:100vw;height:100vh;touch-action:none;}
    .ui{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background: radial-gradient(900px 520px at 50% 30%, rgba(255,255,255,.80), rgba(240,242,255,.40));
      padding:24px; text-align:center;
    }
    .card{
      width:min(560px, 92vw);
      border-radius:20px;
      padding:18px 16px 16px;
      background: rgba(255,255,255,.55);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(30,40,80,.10);
      box-shadow: 0 18px 60px rgba(10,18,40,.12);
      color:var(--txt);
    }
    .title{font-size:18px;font-weight:800;letter-spacing:.2px;margin:0 0 8px;}
    .desc{font-size:13px;color:var(--sub);line-height:1.5;margin:0 0 14px;}
    .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;}
    button{
      appearance:none;border:0; cursor:pointer;
      padding:12px 14px;border-radius:14px;
      background: rgba(255,255,255,.68);
      color: var(--txt); font-weight:750;
      border: 1px solid rgba(20,30,60,.12);
      box-shadow: 0 10px 26px rgba(10,18,40,.10);
    }
    button:active{transform: translateY(1px);}
    .small{margin-top:10px;font-size:12px;color:rgba(15,20,40,.72);line-height:1.45;}
    .badge{
      display:inline-block;margin-top:10px;
      padding:6px 10px;border-radius:999px;
      background: rgba(255,255,255,.60);
      border:1px solid rgba(20,30,60,.10);
      font-size:12px;color:rgba(15,20,40,.72);
    }
    .topHint{
      position:fixed; left:12px; top:10px; z-index:5;
      color:rgba(15,20,40,.72);
      font:12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      user-select:none;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(20,30,60,.10);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 8px 22px rgba(10,18,40,.10);
    }
  </style>
</head>
<body>
  <div class="topHint">Voice Silk — 마이크 허용 후 말해보세요</div>
  <canvas id="c"></canvas>

  <div class="ui" id="ui">
    <div class="card">
      <p class="title">Voice Silk</p>
      <p class="desc">
        소리가 들리면 왼쪽에서 시작한 파형이 오른쪽으로 흐릅니다.<br/>
        파형은 촘촘한 실크 섬유(얇은 선)로 표현되며, 위는 빨강/아래는 보라 무지개 그라데이션입니다.
      </p>
      <div class="row">
        <button id="btnMic">마이크로 시작</button>
        <button id="btnDemo">데모 사운드</button>
      </div>
      <div class="small">
        인스타 인앱 브라우저에서 마이크가 막히면<br/>
        우측 메뉴에서 “브라우저로 열기”로 다시 열어보세요.
      </div>
      <div class="badge" id="status">대기 중</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const ui = document.getElementById("ui");
  const statusEl = document.getElementById("status");
  const btnMic = document.getElementById("btnMic");
  const btnDemo = document.getElementById("btnDemo");

  // ---------- Canvas sizing ----------
  let W=0,H=0,DPR=1;
  let bgCanvas = document.createElement("canvas");
  let bgCtx = bgCanvas.getContext("2d", { alpha: false });

  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";

    bgCanvas.width = W;
    bgCanvas.height = H;

    buildGlassSilkBackground();
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  // ---------- Utility ----------
  const clamp = (x,a,b)=>Math.max(a, Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;

  function smoothNoise(t){
    return (
      Math.sin(t*0.7)*0.55 +
      Math.sin(t*1.7+1.3)*0.25 +
      Math.sin(t*3.1+2.7)*0.20
    );
  }

  // ---------- Background: frosted glass + silk fibers ----------
  function buildGlassSilkBackground(){
    // soft glass base
    const g = bgCtx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#fbfcff");
    g.addColorStop(0.50, "#f3f6ff");
    g.addColorStop(1, "#eef2ff");
    bgCtx.fillStyle = g;
    bgCtx.fillRect(0,0,W,H);

    // subtle iridescent blobs (glass sheen)
    bgCtx.save();
    bgCtx.globalCompositeOperation = "screen";
    for(let i=0;i<6;i++){
      const cx = (0.15 + Math.random()*0.7) * W;
      const cy = (0.15 + Math.random()*0.7) * H;
      const r1 = (0.18 + Math.random()*0.22) * Math.min(W,H);
      const r2 = r1 * (1.4 + Math.random()*0.7);
      const grad = bgCtx.createRadialGradient(cx,cy,r1*0.2, cx,cy,r2);
      grad.addColorStop(0, `rgba(255,255,255,0.35)`);
      grad.addColorStop(0.45, `rgba(220,235,255,0.14)`);
      grad.addColorStop(1, `rgba(255,255,255,0)`);
      bgCtx.fillStyle = grad;
      bgCtx.beginPath();
      bgCtx.ellipse(cx,cy,r2*0.95,r2*0.70, Math.random()*Math.PI, 0, Math.PI*2);
      bgCtx.fill();
    }
    bgCtx.restore();

    // silk-like faint fibers
    bgCtx.save();
    bgCtx.globalCompositeOperation = "multiply";
    bgCtx.lineCap = "round";
    bgCtx.lineJoin = "round";

    const fiberCount = Math.floor((W*H)/(18000*DPR)); // 은은하지만 촘촘
    for(let i=0;i<fiberCount;i++){
      const u = Math.random();
      const v = Math.random();

      const x0 = W*(u*1.18-0.09);
      const y0 = H*(v*1.18-0.09);

      const len = (0.55 + Math.random()*0.85) * Math.max(W,H);
      const ang = (Math.random()*0.45 - 0.225) + (Math.PI*0.04);
      const dx = Math.cos(ang)*len;
      const dy = Math.sin(ang)*len;

      const wob = (0.35 + Math.random()*0.9) * 22 * DPR;

      const x3 = x0 + dx;
      const y3 = y0 + dy;

      const x1 = x0 + dx*0.33 + wob*(Math.random()-0.5);
      const y1 = y0 + dy*0.33 + wob*(Math.random()-0.5);
      const x2 = x0 + dx*0.66 - wob*(Math.random()-0.5);
      const y2 = y0 + dy*0.66 - wob*(Math.random()-0.5);

      const a = 0.018 + Math.random()*0.030;
      const w = (0.35 + Math.random()*0.9)*DPR;

      bgCtx.strokeStyle = `rgba(35,45,90,${a})`;
      bgCtx.lineWidth = w;
      bgCtx.beginPath();
      bgCtx.moveTo(x0,y0);
      bgCtx.bezierCurveTo(x1,y1,x2,y2,x3,y3);
      bgCtx.stroke();
    }
    bgCtx.restore();

    // fine grain (frosted feel)
    const grain = bgCtx.getImageData(0,0,W,H);
    const d = grain.data;
    for(let i=0;i<d.length;i+=4){
      // tiny noise around white
      const n = (Math.random()-0.5) * 10;
      d[i]   = clamp(d[i]   + n, 0, 255);
      d[i+1] = clamp(d[i+1] + n, 0, 255);
      d[i+2] = clamp(d[i+2] + n, 0, 255);
      // alpha ignored (opaque canvas)
    }
    bgCtx.putImageData(grain,0,0);

    // gentle vignette (still bright)
    const vg = bgCtx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.25, W/2,H/2, Math.max(W,H)*0.95);
    vg.addColorStop(0, "rgba(255,255,255,0)");
    vg.addColorStop(1, "rgba(40,60,120,0.08)");
    bgCtx.fillStyle = vg;
    bgCtx.fillRect(0,0,W,H);
  }

  // ---------- Audio ----------
  let audioCtx=null, analyser=null, source=null, stream=null, osc=null, gainNode=null;
  let dataTime=null;

  async function initMic(){
    status("마이크 요청 중…");
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    await audioCtx.resume();

    stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      }
    });

    source = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.8;

    source.connect(analyser);

    dataTime = new Uint8Array(analyser.fftSize);
    status("마이크 연결됨 — 말해보세요");
  }

  async function initDemo(){
    status("데모 사운드 준비 중…");
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    await audioCtx.resume();

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.8;
    dataTime = new Uint8Array(analyser.fftSize);

    osc = audioCtx.createOscillator();
    gainNode = audioCtx.createGain();

    osc.type = "sine";
    osc.frequency.value = 160;
    gainNode.gain.value = 0.0;

    osc.connect(gainNode);
    gainNode.connect(analyser);
    analyser.connect(audioCtx.destination);

    osc.start();

    const t0 = audioCtx.currentTime;
    const pump = () => {
      if(!audioCtx) return;
      const t = audioCtx.currentTime - t0;
      const env = 0.22 + 0.22*Math.max(0, Math.sin(t*1.35)) + 0.10*Math.max(0, Math.sin(t*2.6+1.2));
      gainNode.gain.setTargetAtTime(env, audioCtx.currentTime, 0.05);
      const f = 140 + 90*(0.5+0.5*Math.sin(t*0.78)) + 60*(0.5+0.5*Math.sin(t*1.6+2.0));
      osc.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.06);
      requestAnimationFrame(pump);
    };
    pump();

    status("데모 사운드 실행 중");
  }

  function stopAudio(){
    try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){}
    stream=null;

    try{ if(osc) osc.stop(); }catch(_){}
    osc=null;

    try{ if(audioCtx) audioCtx.close(); }catch(_){}
    audioCtx=null; analyser=null; source=null; gainNode=null; dataTime=null;
  }

  function status(msg){ statusEl.textContent = msg; }

  // ---------- Wave model ----------
  // slices carry volume over time and travel left->right
  const slices = [];
  let lastTime = performance.now();

  // performance knobs (mobile friendly)
  const speedPx = 520;         // wave travel speed
  const maxSlices = 780;       // cap
  const spawnRate = 140;       // smoothness

  let smoothedVol = 0;
  let spawnAcc = 0;

  function computeVolumeRMS(){
    if(!analyser || !dataTime) return 0;
    analyser.getByteTimeDomainData(dataTime);

    let sum = 0;
    for(let i=0;i<dataTime.length;i++){
      const v = (dataTime[i] - 128) / 128;
      sum += v*v;
    }
    return clamp(Math.sqrt(sum / dataTime.length), 0, 1);
  }

  function addSlice(vol){
    slices.push({
      x: 0,
      vol,
      seed: Math.random()*10,
    });
    if(slices.length > maxSlices) slices.splice(0, slices.length - maxSlices);
  }

  // ---------- Premium rainbow mapping (TOP red -> BOTTOM violet, fixed) ----------
  // We create many strands; each strand has fixed "t" in [0..1] from top to bottom.
  // Hue runs from 0 (red) to 270 (violet) so it passes orange/yellow/green/blue.
  function strandColor(t, alpha){
    const hue = 0 + 270*t;             // red -> violet
    const sat = 82;                    // premium vivid but not neon
    const light = lerp(58, 50, t);     // slightly darker towards violet
    return `hsla(${hue.toFixed(1)}, ${sat}%, ${light.toFixed(1)}%, ${alpha})`;
  }

  // ---------- Render ----------
  // Fiber wave settings
  const STRANDS = 56;                 // 촘촘한 얇은 선들
  const BUNDLE_THICKNESS = 34;        // 전체 다발 두께(px @ DPR=1)
  const BASE_LINE_W = 1.05;           // 개별 선 두께

  function draw(now){
    const dt = Math.min(0.05, (now - lastTime)/1000);
    lastTime = now;

    // background
    ctx.drawImage(bgCanvas, 0, 0);

    // update volume
    const vol = computeVolumeRMS();
    smoothedVol = lerp(smoothedVol, vol, 1 - Math.pow(0.001, dt));

    // spawn slices at cadence
    spawnAcc += dt * spawnRate;
    while(spawnAcc >= 1){
      spawnAcc -= 1;
      addSlice(smoothedVol);
    }

    // move slices
    for(const s of slices){
      s.x += speedPx * DPR * dt;
      s.vol *= (1 - 0.12*dt); // gentle decay
    }
    while(slices.length && slices[0].x > W + 60*DPR){
      slices.shift();
    }

    const midY = H * 0.52;

    // wave shape
    const tNow = now*0.0012;
    const spatial = 0.020 * DPR;
    const ampMax = H * 0.18;

    // points from slices
    const pts = [];
    for(const s of slices){
      const env = clamp(s.vol*2.4, 0.02, 1.0);
      const amp = env * ampMax;

      const wob = smoothNoise(tNow + s.seed + s.x*0.002) * 0.25;
      const phase = tNow*3.0 + s.seed*1.5 + s.x*spatial;
      const y = midY + (Math.sin(phase) + wob) * amp;

      pts.push({ x:s.x, y, env, seed:s.seed });
    }

    // draw fiber bundle wave (many thin strands)
    drawFiberBundle(pts, now);

    // moving glass sheen band (subtle)
    drawSheenBand(now);

    requestAnimationFrame(draw);
  }

  function drawFiberBundle(points, now){
    if(points.length < 3) return;

    // speed-safe step
    const step = points.length > 720 ? 2 : 1;

    // bundle thickness (scale with DPR)
    const thick = BUNDLE_THICKNESS * DPR;

    // This makes the bundle look like silk: strands are slightly curved/offset + varying opacity.
    // Top strands = red, bottom = violet (fixed).
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    // faint shadow for depth (works on bright bg)
    ctx.shadowBlur = 18 * DPR;
    ctx.shadowColor = "rgba(10,18,40,0.12)";

    // Base pass (depth)
    for(let k=0;k<STRANDS;k++){
      const t = k/(STRANDS-1);       // 0 top -> 1 bottom
      const offset = (t-0.5)*thick;  // vertical offset
      const alphaBase = 0.035 + 0.05*(1 - Math.abs(t-0.5)*1.2);

      ctx.strokeStyle = strandColor(t, alphaBase);
      ctx.lineWidth = BASE_LINE_W * DPR;

      ctx.beginPath();
      let started=false;

      for(let i=step;i<points.length;i+=step){
        const p0 = points[i-step];
        const p1 = points[i];

        // add micro “fiber flutter”
        const flutter = smoothFlutter(now, p1.x, t) * (1.2*DPR);

        const x0 = p0.x;
        const y0 = p0.y + offset + flutter*(0.8 + 0.6*p0.env);
        const x1 = p1.x;
        const y1 = p1.y + offset + flutter*(0.8 + 0.6*p1.env);

        if(!started){ ctx.moveTo(x0,y0); started=true; }
        ctx.lineTo(x1,y1);
      }
      ctx.stroke();
    }

    // Highlight pass (silk gloss): center-ish strands get extra sheen
    ctx.shadowBlur = 26 * DPR;
    ctx.shadowColor = "rgba(255,255,255,0.25)";
    ctx.globalCompositeOperation = "screen";

    for(let k=0;k<STRANDS;k++){
      const t = k/(STRANDS-1);
      const offset = (t-0.5)*thick;

      // highlight stronger near center with tiny bias upwards (looks premium)
      const centerWeight = Math.exp(-Math.pow((t-0.47)/0.18, 2));
      const alphaHi = 0.010 + 0.060*centerWeight;

      ctx.strokeStyle = strandColor(t, alphaHi);
      ctx.lineWidth = 0.8 * DPR;

      ctx.beginPath();
      let started=false;

      for(let i=step;i<points.length;i+=step){
        const p0 = points[i-step];
        const p1 = points[i];

        const flutter = smoothFlutter(now + 120, p1.x, t) * (1.0*DPR);

        const x0 = p0.x;
        const y0 = p0.y + offset + flutter*(0.9 + 0.7*p0.env);
        const x1 = p1.x;
        const y1 = p1.y + offset + flutter*(0.9 + 0.7*p1.env);

        if(!started){ ctx.moveTo(x0,y0); started=true; }
        ctx.lineTo(x1,y1);
      }
      ctx.stroke();
    }

    ctx.restore();
  }

  function smoothFlutter(now, x, t){
    const tt = now*0.001;
    return (
      Math.sin(tt*2.2 + x*0.004 + t*3.8) * 0.55 +
      Math.sin(tt*1.1 + x*0.006 + t*7.2 + 1.7) * 0.45
    );
  }

  function drawSheenBand(now){
    const tt = now*0.00012;
    const cx = (0.15 + (tt % 1) * 0.85) * W;
    const bandW = 0.22 * W;
    const grad = ctx.createLinearGradient(cx-bandW, 0, cx+bandW, 0);
    grad.addColorStop(0, "rgba(255,255,255,0)");
    grad.addColorStop(0.5, "rgba(255,255,255,0.10)");
    grad.addColorStop(1, "rgba(255,255,255,0)");

    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  // ---------- UI handlers ----------
  btnMic.addEventListener("click", async () => {
    try{
      stopAudio();
      await initMic();
      ui.style.display = "none";
    }catch(err){
      console.error(err);
      status("마이크 권한 실패 — 데모로 시도해보세요");
    }
  });

  btnDemo.addEventListener("click", async () => {
    try{
      stopAudio();
      await initDemo();
      ui.style.display = "none";
    }catch(err){
      console.error(err);
      status("데모 실패 — 브라우저 호환을 확인하세요");
    }
  });

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
