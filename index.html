<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Voice Silk Glass (Debug Safe)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#f4f7ff;}
    canvas{display:block;width:100vw;height:100vh;touch-action:manipulation;}

    .ui{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      padding:24px;
      background: radial-gradient(900px 520px at 50% 25%, rgba(255,255,255,.88), rgba(240,244,255,.55));
      color:#10152b;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .card{
      width:min(560px, 92vw);
      border-radius:22px;
      padding:18px 16px 16px;
      background: rgba(255,255,255,.55);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(40,60,120,.14);
      box-shadow: 0 18px 70px rgba(10,18,40,.14);
    }
    .title{margin:0 0 6px;font-size:18px;font-weight:850;letter-spacing:.2px;}
    .desc{margin:0 0 14px;font-size:13px;line-height:1.5;color:rgba(10,18,40,.72);}
    .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;}
    button{
      border:0; cursor:pointer;
      padding:12px 14px;border-radius:14px;
      background: rgba(255,255,255,.70);
      color:#0f142a; font-weight:800;
      border: 1px solid rgba(40,60,120,.16);
      box-shadow: 0 10px 26px rgba(10,18,40,.12);
    }
    button:active{transform:translateY(1px);}
    .badge{
      display:inline-block;margin-top:10px;
      padding:6px 10px;border-radius:999px;
      background: rgba(255,255,255,.65);
      border:1px solid rgba(40,60,120,.14);
      font-size:12px;color:rgba(10,18,40,.70);
    }
    .hint{
      position:fixed;left:12px;top:10px;z-index:5;
      padding:8px 10px;border-radius:999px;
      background: rgba(255,255,255,.62);
      border: 1px solid rgba(40,60,120,.14);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 8px 22px rgba(10,18,40,.12);
      font:12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:rgba(10,18,40,.72);
      user-select:none;
    }
    .err{
      position:fixed; left:12px; bottom:12px; right:12px; z-index:6;
      padding:10px 12px; border-radius:14px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(255,90,90,.34);
      color:rgba(120,20,20,.90);
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display:none;
      white-space:pre-wrap;
      max-height:35vh;
      overflow:auto;
    }
  </style>
</head>
<body>
  <div class="hint">PC: 버튼 클릭 → 상태 변하는지 확인. (에러 뜨면 아래 빨간 박스)</div>
  <canvas id="c"></canvas>
  <div class="err" id="err"></div>

  <div class="ui" id="ui">
    <div class="card">
      <p class="title">Voice Silk Glass</p>
      <p class="desc">
        버튼이 아무 반응이 없다면 스크립트가 중간에 죽은 상태일 수 있어요.<br/>
        이 버전은 에러를 화면 하단에 띄워서 원인을 바로 보이게 합니다.
      </p>
      <div class="row">
        <button id="btnDemo">데모 사운드</button>
        <button id="btnMic">마이크</button>
      </div>
      <div class="desc" style="margin-top:10px;">
        (마이크는 HTTPS에서만 대부분 동작) / 데모는 보통 어디서든 동작
      </div>
      <div class="badge" id="status">대기 중</div>
    </div>
  </div>

<script>
(() => {
  const errBox = document.getElementById("err");
  const showErr = (e) => {
    errBox.style.display = "block";
    errBox.textContent = String(e?.stack || e);
  };
  window.addEventListener("error", (e)=>showErr(e.error || e.message));
  window.addEventListener("unhandledrejection", (e)=>showErr(e.reason));

  try {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha:false });

    const ui = document.getElementById("ui");
    const statusEl = document.getElementById("status");
    const btnDemo = document.getElementById("btnDemo");
    const btnMic = document.getElementById("btnMic");

    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const rand = (a=1,b=0)=>Math.random()*(a-b)+b;

    let W=0,H=0,DPR=1;
    const bgCanvas = document.createElement("canvas");
    const bgCtx = bgCanvas.getContext("2d", { alpha:false });

    // --- fast, safe grain tile (one-time)
    const noiseTile = document.createElement("canvas");
    noiseTile.width = 96; noiseTile.height = 96;
    const nctx = noiseTile.getContext("2d", { alpha:true });
    {
      const img = nctx.createImageData(96,96);
      const d = img.data;
      for(let i=0;i<d.length;i+=4){
        const v = 245 + ((Math.random()*18)|0) - 9;
        d[i]=v; d[i+1]=v; d[i+2]=v;
        d[i+3]=16 + ((Math.random()*24)|0);
      }
      nctx.putImageData(img,0,0);
    }

    let noisePat = null;

    function prismBlob(cx,cy,r,rot){
      const g = bgCtx.createRadialGradient(cx,cy,r*0.2, cx,cy,r);
      g.addColorStop(0.00, "rgba(255,255,255,0.55)");
      g.addColorStop(0.28, "rgba(210,240,255,0.22)");
      g.addColorStop(0.52, "rgba(235,220,255,0.16)");
      g.addColorStop(0.72, "rgba(255,225,235,0.12)");
      g.addColorStop(1.00, "rgba(255,255,255,0.0)");

      bgCtx.save();
      bgCtx.globalCompositeOperation = "screen";
      bgCtx.translate(cx,cy);
      bgCtx.rotate(rot);
      bgCtx.translate(-cx,-cy);
      bgCtx.fillStyle = g;
      bgCtx.beginPath();
      bgCtx.ellipse(cx,cy,r*1.12,r*0.78,rot,0,Math.PI*2);
      bgCtx.fill();
      bgCtx.restore();
    }

    function buildGlassBackground(){
      const g = bgCtx.createLinearGradient(0,0,0,H);
      g.addColorStop(0, "#ffffff");
      g.addColorStop(0.45, "#f4f7ff");
      g.addColorStop(1, "#eef3ff");
      bgCtx.fillStyle = g;
      bgCtx.fillRect(0,0,W,H);

      for(let i=0;i<7;i++){
        const cx = rand(0.88*W, 0.12*W);
        const cy = rand(0.80*H, 0.12*H);
        const r  = rand(0.30, 0.16) * Math.min(W,H);
        prismBlob(cx,cy,r, rand(Math.PI,0));
      }

      // silk fibers (subtle)
      bgCtx.save();
      bgCtx.globalCompositeOperation = "multiply";
      bgCtx.lineCap = "round";
      const fiberCount = Math.floor((W*H)/(17000*DPR));
      for(let i=0;i<fiberCount;i++){
        const x0 = rand(W*1.1, -W*0.1);
        const y0 = rand(H*1.1, -H*0.1);
        const len = rand(1.2,0.55)*Math.max(W,H);
        const ang = (rand(0.55,-0.55))*0.35 + Math.PI*0.04;
        const dx = Math.cos(ang)*len;
        const dy = Math.sin(ang)*len;
        const wob = rand(26,10)*DPR;

        const x3 = x0 + dx, y3 = y0 + dy;
        const x1 = x0 + dx*0.33 + wob*(Math.random()-0.5);
        const y1 = y0 + dy*0.33 + wob*(Math.random()-0.5);
        const x2 = x0 + dx*0.66 - wob*(Math.random()-0.5);
        const y2 = y0 + dy*0.66 - wob*(Math.random()-0.5);

        bgCtx.strokeStyle = `rgba(40,60,120,${rand(0.050,0.020)})`;
        bgCtx.lineWidth = rand(1.0,0.35)*DPR;
        bgCtx.beginPath();
        bgCtx.moveTo(x0,y0);
        bgCtx.bezierCurveTo(x1,y1,x2,y2,x3,y3);
        bgCtx.stroke();
      }
      bgCtx.restore();

      // frosted grain
      noisePat = bgCtx.createPattern(noiseTile, "repeat");
      bgCtx.save();
      bgCtx.globalCompositeOperation = "soft-light";
      bgCtx.globalAlpha = 0.25;
      bgCtx.fillStyle = noisePat;
      bgCtx.fillRect(0,0,W,H);
      bgCtx.restore();

      const vg = bgCtx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.30, W/2,H/2, Math.max(W,H)*0.98);
      vg.addColorStop(0, "rgba(255,255,255,0)");
      vg.addColorStop(1, "rgba(20,35,90,0.09)");
      bgCtx.fillStyle = vg;
      bgCtx.fillRect(0,0,W,H);
    }

    function resize(){
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = Math.floor(innerWidth * DPR);
      H = Math.floor(innerHeight * DPR);
      canvas.width = W; canvas.height = H;
      canvas.style.width = innerWidth + "px";
      canvas.style.height = innerHeight + "px";

      bgCanvas.width = W;
      bgCanvas.height = H;
      buildGlassBackground();
    }
    addEventListener("resize", resize, { passive:true });
    resize();

    // --- audio
    let audioCtx=null, analyser=null, stream=null, source=null;
    let osc=null, gainNode=null;
    let dataTime=null;

    function status(msg){ statusEl.textContent = msg; }

    function stopAudio(){
      try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){}
      stream=null;
      try{ if(osc) osc.stop(); }catch(_){}
      osc=null;
      try{ if(audioCtx) audioCtx.close(); }catch(_){}
      audioCtx=null; analyser=null; source=null; gainNode=null; dataTime=null;
    }

    async function initDemo(){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.resume();

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = 0.82;
      dataTime = new Uint8Array(analyser.fftSize);

      osc = audioCtx.createOscillator();
      gainNode = audioCtx.createGain();
      osc.type = "sine";
      gainNode.gain.value = 0.0;

      osc.connect(gainNode);
      gainNode.connect(analyser);
      analyser.connect(audioCtx.destination);
      osc.start();

      const t0 = audioCtx.currentTime;
      const pump = () => {
        if(!audioCtx) return;
        const t = audioCtx.currentTime - t0;
        const env = 0.18 + 0.22*Math.max(0, Math.sin(t*1.25)) + 0.12*Math.max(0, Math.sin(t*2.35+1.2));
        gainNode.gain.setTargetAtTime(env, audioCtx.currentTime, 0.06);
        const f = 150 + 85*(0.5+0.5*Math.sin(t*0.72)) + 55*(0.5+0.5*Math.sin(t*1.45+2.0));
        osc.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.08);
        requestAnimationFrame(pump);
      };
      pump();
    }

    async function initMic(){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.resume();

      stream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
      });

      source = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = 0.82;
      dataTime = new Uint8Array(analyser.fftSize);

      source.connect(analyser);
    }

    function computeVolumeRMS(){
      if(!analyser || !dataTime) return 0;
      analyser.getByteTimeDomainData(dataTime);
      let sum=0;
      for(let i=0;i<dataTime.length;i++){
        const v=(dataTime[i]-128)/128;
        sum += v*v;
      }
      return clamp(Math.sqrt(sum/dataTime.length), 0, 1);
    }

    // --- icy colors (fixed by strand position, not random)
    function icyColor(t, a){
      let hue;
      if(t < 0.55){
        const u = t/0.55;
        hue = lerp(330, 205, u); // magenta -> icy blue
      }else{
        const u = (t-0.55)/0.45;
        hue = lerp(205, 270, u); // icy blue -> violet
      }
      const sat = 65;
      const light = lerp(74, 62, t);
      return `hsla(${hue.toFixed(1)}, ${sat}%, ${light.toFixed(1)}%, ${a})`;
    }

    // --- wave model
    const slices=[];
    let smoothedVol=0;
    let spawnAcc=0;
    let lastTime=performance.now();

    const speedPx=520;
    const maxSlices=820;
    const spawnRate=150;

    const STRANDS=64;
    const BUNDLE_THICKNESS=42;
    const LINE_W=0.85;

    // beads
    const beads=[];
    function spawnBead(vol){
      const p = clamp((vol-0.05)*2.2, 0, 1);
      if(Math.random() > p) return;
      beads.push({ x:0, life:1.0, t:Math.random(), r:(2.5+10*vol)*DPR, seed:Math.random()*10 });
      if(beads.length > 90) beads.splice(0, beads.length-90);
    }
    function sampleY(points, x){
      for(let i=1;i<points.length;i++){
        const p0=points[i-1], p1=points[i];
        if(p0.x <= x && x <= p1.x){
          const t=(x-p0.x)/Math.max(1e-6,(p1.x-p0.x));
          return lerp(p0.y,p1.y,t);
        }
      }
      return null;
    }
    function fiberFlutter(now, x, t){
      const tt = now*0.001;
      return (
        Math.sin(tt*2.1 + x*0.004 + t*4.2) * 0.55 +
        Math.sin(tt*1.0 + x*0.006 + t*8.0 + 1.8) * 0.45
      );
    }

    function drawSilkBundle(points, now){
      if(points.length < 3) return;
      const step = points.length > 760 ? 2 : 1;
      const thick = BUNDLE_THICKNESS*DPR;

      ctx.save();
      ctx.lineCap="round";
      ctx.lineJoin="round";

      ctx.shadowBlur = 16*DPR;
      ctx.shadowColor = "rgba(10,18,40,0.10)";

      for(let k=0;k<STRANDS;k++){
        const t = k/(STRANDS-1);
        const off = (t-0.5)*thick;
        const centerWeight = Math.exp(-Math.pow((t-0.50)/0.22,2));
        const a = 0.030 + 0.055*centerWeight;

        ctx.strokeStyle = icyColor(t, a);
        ctx.lineWidth = LINE_W*DPR;

        ctx.beginPath();
        let started=false;
        for(let i=step;i<points.length;i+=step){
          const p0=points[i-step], p1=points[i];
          const flutter = fiberFlutter(now, p1.x, t) * (1.25*DPR);
          const x0=p0.x, y0=p0.y + off + flutter*(0.8+0.7*p0.env);
          const x1=p1.x, y1=p1.y + off + flutter*(0.8+0.7*p1.env);
          if(!started){ ctx.moveTo(x0,y0); started=true; }
          ctx.lineTo(x1,y1);
        }
        ctx.stroke();
      }

      ctx.globalCompositeOperation="screen";
      ctx.shadowBlur = 24*DPR;
      ctx.shadowColor = "rgba(255,255,255,0.30)";

      for(let k=0;k<STRANDS;k++){
        const t = k/(STRANDS-1);
        const off = (t-0.5)*thick;
        const band = Math.exp(-Math.pow((t-0.43)/0.18,2));
        const a = 0.010 + 0.080*band;

        ctx.strokeStyle = icyColor(t, a);
        ctx.lineWidth = 0.65*DPR;

        ctx.beginPath();
        let started=false;
        for(let i=step;i<points.length;i+=step){
          const p0=points[i-step], p1=points[i];
          const flutter = fiberFlutter(now+140, p1.x, t) * (1.0*DPR);
          const x0=p0.x, y0=p0.y + off + flutter*(0.9+0.8*p0.env);
          const x1=p1.x, y1=p1.y + off + flutter*(0.9+0.8*p1.env);
          if(!started){ ctx.moveTo(x0,y0); started=true; }
          ctx.lineTo(x1,y1);
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawBeads(points, dt){
      if(points.length < 3) return;
      for(const b of beads){
        b.x += speedPx*DPR*dt;
        b.life *= (1 - 0.18*dt);
      }
      while(beads.length && (beads[0].x > W + 120*DPR || beads[0].life < 0.08)) beads.shift();

      ctx.save();
      ctx.globalCompositeOperation="screen";
      for(const b of beads){
        const yBase = sampleY(points, b.x);
        if(yBase == null) continue;
        const thick = BUNDLE_THICKNESS*DPR;
        const off = (b.t-0.5)*thick;
        const y = yBase + off + Math.sin(b.seed + b.x*0.01)*1.2*DPR;
        const r = b.r;
        const a = clamp(0.10 + 0.55*b.life, 0, 0.65);

        const grad = ctx.createRadialGradient(b.x - r*0.35, y - r*0.35, r*0.2, b.x, y, r);
        grad.addColorStop(0.00, `rgba(255,255,255,${0.85*a})`);
        grad.addColorStop(0.35, icyColor(b.t, 0.55*a));
        grad.addColorStop(0.70, `rgba(190,230,255,${0.22*a})`);
        grad.addColorStop(1.00, `rgba(255,255,255,0)`);

        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(b.x, y, r, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = `rgba(255,255,255,${0.45*a})`;
        ctx.beginPath(); ctx.arc(b.x - r*0.28, y - r*0.28, r*0.25, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    function drawSheenSweep(now){
      const tt = (now*0.00018) % 1;
      const cx = (0.15 + 0.85*tt) * W;
      const w = 0.18*W;
      const g = ctx.createLinearGradient(cx-w, 0, cx+w, 0);
      g.addColorStop(0.00, "rgba(255,255,255,0)");
      g.addColorStop(0.50, "rgba(255,255,255,0.12)");
      g.addColorStop(1.00, "rgba(255,255,255,0)");
      ctx.save();
      ctx.globalCompositeOperation="screen";
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    // --- main loop
    function animate(now){
      const dt = Math.min(0.05, (now-lastTime)/1000);
      lastTime = now;

      ctx.drawImage(bgCanvas,0,0);

      const vol = computeVolumeRMS();
      smoothedVol = lerp(smoothedVol, vol, 1 - Math.pow(0.001, dt));

      spawnAcc += dt*spawnRate;
      while(spawnAcc >= 1){
        spawnAcc -= 1;
        slices.push({ x:0, vol:smoothedVol, seed:Math.random()*10 });
        if(slices.length > maxSlices) slices.splice(0, slices.length-maxSlices);
        spawnBead(smoothedVol);
      }

      for(const s of slices){
        s.x += speedPx*DPR*dt;
        s.vol *= (1 - 0.12*dt);
      }
      while(slices.length && slices[0].x > W + 100*DPR) slices.shift();

      const midY = H*0.54;
      const tNow = now*0.0011;
      const spatial = 0.020*DPR;
      const ampMax = H*0.17;

      const pts=[];
      for(const s of slices){
        const env = clamp(s.vol*2.7, 0.02, 1.0);
        const amp = env*ampMax;
        const wob = (
          Math.sin((tNow+s.seed)*0.7)*0.55 +
          Math.sin((tNow*1.4+s.seed+1.3)*1.7)*0.25 +
          Math.sin((tNow*2.2+s.seed+2.7)*3.1)*0.20
        ) * 0.26;
        const phase = tNow*3.0 + s.seed*1.6 + s.x*spatial;
        const y = midY + (Math.sin(phase)+wob)*amp;
        pts.push({ x:s.x, y, env, seed:s.seed });
      }

      drawSilkBundle(pts, now);
      drawBeads(pts, dt);
      drawSheenSweep(now);

      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // --- Start handlers (THIS is what you need to test)
    btnDemo.addEventListener("click", async () => {
      try{
        status("버튼 클릭됨: 데모 시작 중…");
        stopAudio();
        await initDemo();
        status("데모 실행 중");
        ui.style.display="none";
      }catch(e){
        showErr(e);
        status("데모 실패(에러 확인)");
      }
    });

    btnMic.addEventListener("click", async () => {
      try{
        status("버튼 클릭됨: 마이크 요청 중…");
        stopAudio();
        await initMic();
        status("마이크 연결됨");
        ui.style.display="none";
      }catch(e){
        showErr(e);
        status("마이크 실패(HTTPS/권한 확인)");
      }
    });

    // sanity check
    status("대기 중 (JS 정상 로드됨) — 버튼을 눌러보세요");

  } catch (e) {
    showErr(e);
  }
})();
</script>
</body>
</html>
