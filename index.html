<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Glass Voice Wave</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#f3f6ff;}
    canvas{display:block;width:100vw;height:100vh;touch-action:manipulation;}
    .ui{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:24px;
      background: radial-gradient(900px 520px at 50% 25%, rgba(255,255,255,.90), rgba(240,244,255,.55));
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:#0f1430;
    }
    .card{
      width:min(560px, 92vw);
      border-radius:22px;
      padding:18px 16px 16px;
      background: rgba(255,255,255,.58);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(40,60,120,.14);
      box-shadow: 0 18px 70px rgba(10,18,40,.14);
      text-align:center;
    }
    .title{margin:0 0 8px;font-size:18px;font-weight:900;letter-spacing:.2px;}
    .desc{margin:0 0 14px;font-size:13px;line-height:1.5;color:rgba(10,18,40,.72);}
    button{
      border:0; cursor:pointer;
      padding:12px 16px;border-radius:14px;
      background: rgba(255,255,255,.72);
      color:#0f1430; font-weight:900;
      border: 1px solid rgba(40,60,120,.16);
      box-shadow: 0 10px 26px rgba(10,18,40,.12);
    }
    button:active{transform: translateY(1px);}
    .badge{
      display:inline-block;margin-top:10px;
      padding:6px 10px;border-radius:999px;
      background: rgba(255,255,255,.66);
      border:1px solid rgba(40,60,120,.14);
      font-size:12px;color:rgba(10,18,40,.70);
    }
    .hint{
      position:fixed;left:12px;top:10px;z-index:5;
      padding:8px 10px;border-radius:999px;
      background: rgba(255,255,255,.64);
      border: 1px solid rgba(40,60,120,.14);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 8px 22px rgba(10,18,40,.12);
      font:12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:rgba(10,18,40,.72);
      user-select:none;
    }
  </style>
</head>
<body>
  <div class="hint">Mic only · 유리 배경 + 세로 스트랜드 파동 (최적화)</div>
  <canvas id="c"></canvas>

  <div class="ui" id="ui">
    <div class="card">
      <p class="title">Glass Voice Wave</p>
      <p class="desc">
        “이어진 선분” 없이, 세로 얇은 선들이 촘촘히 쌓여 파동처럼 보입니다.<br/>
        색은 항상 위=빨강, 아래=보라 무지개 그라데이션(유리 톤)입니다.
      </p>
      <button id="btnMic">마이크 시작</button>
      <div class="desc" style="margin-top:10px;">
        마이크는 HTTPS에서 동작합니다. (GitHub Pages OK)
      </div>
      <div class="badge" id="status">대기 중</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const ui = document.getElementById("ui");
  const btnMic = document.getElementById("btnMic");
  const statusEl = document.getElementById("status");
  const status = (t)=>statusEl.textContent=t;

  // --- perf knobs (중요)
  // DPR 제한: 모바일/인앱에서 렉 방지 핵심
  let DPR = 1;
  let W=0,H=0;

  // background cache
  const bg = document.createElement("canvas");
  const bgx = bg.getContext("2d", { alpha:false });

  // wave ping-pong (전체 재렌더 X, shift만)
  let waveA = document.createElement("canvas");
  let waveB = document.createElement("canvas");
  let wA = waveA.getContext("2d", { alpha:true });
  let wB = waveB.getContext("2d", { alpha:true });

  // audio
  let audioCtx=null, analyser=null, source=null, stream=null;
  let dataTime=null;

  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;

  function resize(){
    DPR = Math.min(1.5, window.devicePixelRatio || 1); // <-- 최적화 포인트
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = innerWidth+"px";
    canvas.style.height = innerHeight+"px";

    bg.width = W; bg.height = H;
    waveA.width = W; waveA.height = H;
    waveB.width = W; waveB.height = H;

    // clear wave buffers
    wA.clearRect(0,0,W,H);
    wB.clearRect(0,0,W,H);

    buildGlassBackground();
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  // ---- Background (유리 느낌, 매우 가벼움: per-pixel 루프 없음)
  function buildGlassBackground(){
    // base gradient
    const g = bgx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#ffffff");
    g.addColorStop(0.45, "#f3f6ff");
    g.addColorStop(1, "#edf2ff");
    bgx.fillStyle = g;
    bgx.fillRect(0,0,W,H);

    // prismatic blobs (몇 개만)
    for(let i=0;i<6;i++){
      const cx = (0.12 + Math.random()*0.76)*W;
      const cy = (0.12 + Math.random()*0.76)*H;
      const r  = (0.12 + Math.random()*0.18)*Math.min(W,H);
      const rg = bgx.createRadialGradient(cx,cy,r*0.15, cx,cy,r);
      rg.addColorStop(0.00, "rgba(255,255,255,0.60)");
      rg.addColorStop(0.30, "rgba(210,240,255,0.22)");
      rg.addColorStop(0.55, "rgba(235,220,255,0.16)");
      rg.addColorStop(0.75, "rgba(255,225,235,0.12)");
      rg.addColorStop(1.00, "rgba(255,255,255,0.0)");
      bgx.save();
      bgx.globalCompositeOperation = "screen";
      bgx.fillStyle = rg;
      bgx.beginPath();
      bgx.ellipse(cx,cy,r*1.15,r*0.78, Math.random()*Math.PI, 0, Math.PI*2);
      bgx.fill();
      bgx.restore();
    }

    // frosted grain: 작은 타일 패턴 1회 생성 후 패턴 채우기 (가벼움)
    const tile = document.createElement("canvas");
    tile.width = 96; tile.height = 96;
    const tctx = tile.getContext("2d", { alpha:true });
    const img = tctx.createImageData(96,96);
    const d = img.data;
    for(let i=0;i<d.length;i+=4){
      const v = 245 + ((Math.random()*18)|0) - 9;
      d[i]=v; d[i+1]=v; d[i+2]=v;
      d[i+3]=14 + ((Math.random()*22)|0);
    }
    tctx.putImageData(img,0,0);

    const pat = bgx.createPattern(tile, "repeat");
    bgx.save();
    bgx.globalCompositeOperation = "soft-light";
    bgx.globalAlpha = 0.22;
    bgx.fillStyle = pat;
    bgx.fillRect(0,0,W,H);
    bgx.restore();

    // subtle vignette (밝게 유지)
    const vg = bgx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.35, W/2,H/2, Math.max(W,H)*0.98);
    vg.addColorStop(0, "rgba(255,255,255,0)");
    vg.addColorStop(1, "rgba(20,35,90,0.08)");
    bgx.fillStyle = vg;
    bgx.fillRect(0,0,W,H);
  }

  // ---- Audio: RMS volume only (가장 가벼움)
  async function startMic(){
    status("마이크 요청 중…");
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    await audioCtx.resume();

    stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
    });

    source = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;              // 가볍게
    analyser.smoothingTimeConstant = 0.85;
    source.connect(analyser);

    dataTime = new Uint8Array(analyser.fftSize);
    status("마이크 연결됨");
  }

  function computeRMS(){
    if(!analyser || !dataTime) return 0;
    analyser.getByteTimeDomainData(dataTime);
    let sum = 0;
    for(let i=0;i<dataTime.length;i++){
      const v = (dataTime[i]-128)/128;
      sum += v*v;
    }
    return clamp(Math.sqrt(sum/dataTime.length), 0, 1);
  }

  // ---- Wave columns: 세로 스트랜드 컬럼만 (이어지는 선분 X)
  // shift 방식: waveA를 waveB에 dx만큼 밀어넣고, x=0에 새 컬럼 찍기
  const midFactor = 0.54;
  const speed = 360;          // px/sec (DPR 포함 적용)
  const colW = 6;             // 새 컬럼 폭(px @ DPR=1). 촘촘할수록 작게
  const strandCount = 6;      // 컬럼 안에서 1px 스트랜드 몇 줄로 보일지

  // glassy rainbow gradient: 항상 위 red -> 아래 violet
  // (HSL hue 0 -> 270)
  function makeRainbowGradient(y1,y2, alpha=1){
    const g = wB.createLinearGradient(0,y1,0,y2);
    // 무지개 스펙트럼 고정
    g.addColorStop(0.00, `hsla(0,   90%, 62%, ${alpha})`);   // red
    g.addColorStop(0.16, `hsla(35,  92%, 62%, ${alpha})`);   // orange
    g.addColorStop(0.33, `hsla(60,  90%, 62%, ${alpha})`);   // yellow
    g.addColorStop(0.50, `hsla(135, 85%, 60%, ${alpha})`);   // green
    g.addColorStop(0.66, `hsla(200, 88%, 62%, ${alpha})`);   // cyan/blue
    g.addColorStop(0.82, `hsla(235, 88%, 62%, ${alpha})`);   // deep blue
    g.addColorStop(1.00, `hsla(270, 88%, 62%, ${alpha})`);   // violet
    return g;
  }

  let last = performance.now();
  let acc = 0;
  let smVol = 0;

  function drawColumn(vol){
    const midY = H * midFactor;
    const ampMax = H * 0.22;          // 최대 진폭
    const amp = (0.02 + vol*1.05) * ampMax;

    const y1 = midY - amp;
    const y2 = midY + amp;

    // 컬럼 자체가 "유리"처럼 보이게: 컬럼 안 여러 스트랜드 + 하이라이트
    const baseGrad = makeRainbowGradient(y1,y2, 0.58);
    const hiGrad   = makeRainbowGradient(y1,y2, 0.30);

    // base pass
    wB.save();
    wB.globalCompositeOperation = "source-over";
    wB.lineCap = "round";
    wB.shadowBlur = 10 * DPR;
    wB.shadowColor = "rgba(255,255,255,0.22)";

    for(let s=0;s<strandCount;s++){
      const t = strandCount<=1 ? 0.5 : s/(strandCount-1);
      // 가운데가 더 밝게
      const a = 0.10 + 0.18 * Math.exp(-Math.pow((t-0.5)/0.32,2));
      const x = (s * (colW*DPR)/(strandCount-1 || 1));

      wB.globalAlpha = a;
      wB.strokeStyle = baseGrad;
      wB.lineWidth = 1.0 * DPR;
      wB.beginPath();
      wB.moveTo(x, y1);
      wB.lineTo(x, y2);
      wB.stroke();
    }
    wB.restore();

    // highlight pass (screen) : 유리 스펙
    wB.save();
    wB.globalCompositeOperation = "screen";
    wB.shadowBlur = 16 * DPR;
    wB.shadowColor = "rgba(255,255,255,0.28)";

    // 중앙 하이라이트 1~2줄만
    const cx = (colW*DPR) * 0.55;
    wB.strokeStyle = hiGrad;
    wB.globalAlpha = 0.55;
    wB.lineWidth = 0.9 * DPR;
    wB.beginPath();
    wB.moveTo(cx, y1);
    wB.lineTo(cx, y2);
    wB.stroke();

    wB.strokeStyle = "rgba(255,255,255,0.38)";
    wB.globalAlpha = 0.25;
    wB.lineWidth = 0.7 * DPR;
    wB.beginPath();
    wB.moveTo(cx - 1.2*DPR, y1 + 1.2*DPR);
    wB.lineTo(cx - 1.2*DPR, y2 - 1.2*DPR);
    wB.stroke();

    wB.restore();
  }

  function step(now){
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    // background draw
    ctx.drawImage(bg, 0, 0);

    // update volume (smoothing)
    const v = computeRMS();
    smVol = lerp(smVol, v, 1 - Math.pow(0.001, dt));

    // determine how many pixels to shift this frame
    acc += speed * DPR * dt;

    // ping-pong shift in chunks of colW to keep columns crisp
    const stepPx = Math.max(1, Math.floor(colW * DPR));
    const shifts = Math.floor(acc / stepPx);
    if(shifts > 0){
      acc -= shifts * stepPx;

      // copy A -> B shifted right
      // (B를 깨끗하게 만들고, A를 오른쪽으로 밀어넣기)
      wB.setTransform(1,0,0,1,0,0);
      wB.clearRect(0,0,W,H);
      wB.drawImage(waveA, shifts*stepPx, 0);

      // 아주 약한 잔상 페이드 (과포화/번짐 방지)
      wB.save();
      wB.globalCompositeOperation = "destination-in";
      wB.fillStyle = "rgba(255,255,255,0.985)";
      wB.fillRect(0,0,W,H);
      wB.restore();

      // draw new columns for each shift step
      for(let i=0;i<shifts;i++){
        // x=0에 새 컬럼 (세로 스트랜드 다발) 찍기
        drawColumn(smVol);
        // 다음 컬럼을 위해 이미지를 다시 stepPx만큼 더 밀지는 않음:
        // shifts가 크면 여러 컬럼이 같은 x에 겹치므로, 약간 x오프셋으로 밀어줌
        // -> 아주 싸게: 현재 B를 왼쪽으로 아주 약간 당겨서 다음 컬럼 공간 확보
        if(i < shifts-1){
          // B를 stepPx만큼 다시 오른쪽으로 밀어 "다음 컬럼 자리" 만들기
          const tmp = waveA; waveA = waveB; waveB = tmp;
          wA = waveA.getContext("2d", { alpha:true });
          wB = waveB.getContext("2d", { alpha:true });

          wB.clearRect(0,0,W,H);
          wB.drawImage(waveA, stepPx, 0);

          wB.save();
          wB.globalCompositeOperation = "destination-in";
          wB.fillStyle = "rgba(255,255,255,0.985)";
          wB.fillRect(0,0,W,H);
          wB.restore();
        }
      }

      // swap buffers at end (B is newest)
      const t = waveA; waveA = waveB; waveB = t;
      wA = waveA.getContext("2d", { alpha:true });
      wB = waveB.getContext("2d", { alpha:true });
    }

    // composite wave over bg
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.drawImage(waveA, 0, 0);
    ctx.restore();

    // subtle moving glass sheen (cheap)
    const tt = (now*0.00016) % 1;
    const cx = (0.1 + 0.9*tt)*W;
    const w = 0.18*W;
    const sg = ctx.createLinearGradient(cx-w,0,cx+w,0);
    sg.addColorStop(0.00,"rgba(255,255,255,0)");
    sg.addColorStop(0.50,"rgba(255,255,255,0.10)");
    sg.addColorStop(1.00,"rgba(255,255,255,0)");
    ctx.save();
    ctx.globalCompositeOperation="screen";
    ctx.fillStyle = sg;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  // ---- UI
  btnMic.addEventListener("click", async () => {
    try{
      status("버튼 클릭됨: 시작 중…");
      await startMic();
      ui.style.display = "none";
    }catch(e){
      console.error(e);
      status("마이크 실패: HTTPS/권한 확인");
    }
  });

})();
</script>
</body>
</html>
