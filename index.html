<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Glass Voice Columns</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#f3f6ff;}
    canvas{display:block;width:100vw;height:100vh;touch-action:manipulation;}

    .ui{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:24px;
      background: radial-gradient(900px 520px at 50% 25%, rgba(255,255,255,.90), rgba(240,244,255,.55));
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:#0f1430;
      z-index:10;
    }
    .card{
      width:min(560px, 92vw);
      border-radius:22px;
      padding:18px 16px 16px;
      background: rgba(255,255,255,.58);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(40,60,120,.14);
      box-shadow: 0 18px 70px rgba(10,18,40,.14);
      text-align:center;
    }
    .title{margin:0 0 8px;font-size:18px;font-weight:900;letter-spacing:.2px;}
    .desc{margin:0 0 14px;font-size:13px;line-height:1.5;color:rgba(10,18,40,.72);}
    button{
      border:0; cursor:pointer;
      padding:12px 16px;border-radius:14px;
      background: rgba(255,255,255,.72);
      color:#0f1430; font-weight:900;
      border: 1px solid rgba(40,60,120,.16);
      box-shadow: 0 10px 26px rgba(10,18,40,.12);
    }
    button:active{transform: translateY(1px);}
    .badge{
      display:inline-block;margin-top:10px;
      padding:6px 10px;border-radius:999px;
      background: rgba(255,255,255,.66);
      border:1px solid rgba(40,60,120,.14);
      font-size:12px;color:rgba(10,18,40,.70);
    }

    .pill{
      position:fixed; left:12px; top:10px; z-index:11;
      padding:8px 10px;border-radius:999px;
      background: rgba(255,255,255,.64);
      border: 1px solid rgba(40,60,120,.14);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 8px 22px rgba(10,18,40,.12);
      font:12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:rgba(10,18,40,.72);
      user-select:none;
    }

    .err{
      position:fixed; left:12px; right:12px; bottom:12px; z-index:12;
      padding:10px 12px; border-radius:14px;
      background: rgba(255,255,255,.78);
      border:1px solid rgba(255,90,90,.34);
      color:rgba(120,20,20,.90);
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display:none;
      white-space:pre-wrap;
      max-height:35vh;
      overflow:auto;
    }
  </style>
</head>
<body>
  <div class="pill" id="pill">Tap to start/stop (after Start)</div>
  <canvas id="c"></canvas>
  <div class="err" id="err"></div>

  <div class="ui" id="ui">
    <div class="card">
      <p class="title">Glass Voice Columns</p>
      <p class="desc">
        요동 없이, 세로 섬유 컬럼이 왼→오로 이동합니다.<br/>
        길이만 음량에 비례해 변하고, “절대 높이” 기준으로 위=빨강 / 아래=보라 무지개가 나타납니다.<br/>
        시작 후 화면을 터치하면 멈춤/재시작 토글됩니다.
      </p>
      <button id="btnStart">Start</button>
      <div class="desc" style="margin-top:10px;">
        마이크는 HTTPS에서 동작합니다 (GitHub Pages OK).
      </div>
      <div class="badge" id="status">대기 중</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const ui = document.getElementById("ui");
  const btnStart = document.getElementById("btnStart");
  const statusEl = document.getElementById("status");
  const pill = document.getElementById("pill");
  const errBox = document.getElementById("err");

  const showErr = (e) => {
    errBox.style.display = "block";
    errBox.textContent = String(e?.stack || e);
  };
  window.addEventListener("error", (e)=>showErr(e.error || e.message));
  window.addEventListener("unhandledrejection", (e)=>showErr(e.reason));

  const status = (t)=>statusEl.textContent=t;

  // ---------------- Perf knobs ----------------
  let DPR = 1;
  let W=0,H=0;

  // Background cache
  const bg = document.createElement("canvas");
  const bgx = bg.getContext("2d", { alpha:false });

  // Wave buffers (ping-pong)
  const waveA = document.createElement("canvas");
  const waveB = document.createElement("canvas");
  const wA = waveA.getContext("2d", { alpha:true });
  const wB = waveB.getContext("2d", { alpha:true });

  let front = waveA, back = waveB;
  let frontCtx = wA, backCtx = wB;

  // Audio
  let audioCtx=null, analyser=null, source=null, stream=null;
  let dataTime=null;

  // State
  let hasStarted = false;
  let running = false; // toggle by touch after start

  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;

  // ---------------- Background (glass) ----------------
  const noiseTile = document.createElement("canvas");
  noiseTile.width = 96; noiseTile.height = 96;
  const nt = noiseTile.getContext("2d", { alpha:true });
  {
    const img = nt.createImageData(96,96);
    const d = img.data;
    for(let i=0;i<d.length;i+=4){
      const v = 245 + ((Math.random()*18)|0) - 9;
      d[i]=v; d[i+1]=v; d[i+2]=v;
      d[i+3]=14 + ((Math.random()*22)|0);
    }
    nt.putImageData(img,0,0);
  }

  function buildGlassBackground(){
    const g = bgx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#ffffff");
    g.addColorStop(0.45, "#f3f6ff");
    g.addColorStop(1, "#edf2ff");
    bgx.fillStyle = g;
    bgx.fillRect(0,0,W,H);

    for(let i=0;i<6;i++){
      const cx = (0.12 + Math.random()*0.76)*W;
      const cy = (0.12 + Math.random()*0.76)*H;
      const r  = (0.12 + Math.random()*0.18)*Math.min(W,H);
      const rg = bgx.createRadialGradient(cx,cy,r*0.15, cx,cy,r);
      rg.addColorStop(0.00, "rgba(255,255,255,0.55)");
      rg.addColorStop(0.30, "rgba(210,240,255,0.20)");
      rg.addColorStop(0.55, "rgba(235,220,255,0.15)");
      rg.addColorStop(0.75, "rgba(255,225,235,0.11)");
      rg.addColorStop(1.00, "rgba(255,255,255,0.0)");
      bgx.save();
      bgx.globalCompositeOperation = "screen";
      bgx.fillStyle = rg;
      bgx.beginPath();
      bgx.ellipse(cx,cy,r*1.15,r*0.78, Math.random()*Math.PI, 0, Math.PI*2);
      bgx.fill();
      bgx.restore();
    }

    const pat = bgx.createPattern(noiseTile, "repeat");
    bgx.save();
    bgx.globalCompositeOperation = "soft-light";
    bgx.globalAlpha = 0.22;
    bgx.fillStyle = pat;
    bgx.fillRect(0,0,W,H);
    bgx.restore();

    const vg = bgx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.35, W/2,H/2, Math.max(W,H)*0.98);
    vg.addColorStop(0, "rgba(255,255,255,0)");
    vg.addColorStop(1, "rgba(20,35,90,0.08)");
    bgx.fillStyle = vg;
    bgx.fillRect(0,0,W,H);
  }

  function resize(){
    DPR = Math.min(1.5, window.devicePixelRatio || 1);
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);

    canvas.width = W; canvas.height = H;
    canvas.style.width = innerWidth+"px";
    canvas.style.height = innerHeight+"px";

    bg.width = W; bg.height = H;
    waveA.width = W; waveA.height = H;
    waveB.width = W; waveB.height = H;

    wA.clearRect(0,0,W,H);
    wB.clearRect(0,0,W,H);

    front = waveA; back = waveB;
    frontCtx = wA; backCtx = wB;

    buildGlassBackground();
    refreshGradients(); // because H changed / contexts might change
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  // ---------------- Audio ----------------
  async function startMic(){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    await audioCtx.resume();

    stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
    });

    source = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.85;
    source.connect(analyser);

    dataTime = new Uint8Array(analyser.fftSize);
  }

  function computeRMS(){
    if(!analyser || !dataTime) return 0;
    analyser.getByteTimeDomainData(dataTime);
    let sum = 0;
    for(let i=0;i<dataTime.length;i++){
      const v = (dataTime[i]-128)/128;
      sum += v*v;
    }
    return clamp(Math.sqrt(sum/dataTime.length), 0, 1);
  }

  // ---------------- Columns (NO WOBBLE) ----------------
  const midYFactor = 0.54;
  const speed = 420;      // px/sec (move)
  const colW = 6;         // column width
  const strands = 7;      // fibers inside column

  // Absolute-height rainbow (red top, violet bottom)
  let baseGrad = null;
  let hiGrad = null;

  function rainbowGradientAbsolute(alpha){
    const g = backCtx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0.00, `hsla(0,   100%, 52%, ${alpha})`);
    g.addColorStop(0.16, `hsla(30,  100%, 52%, ${alpha})`);
    g.addColorStop(0.33, `hsla(55,  100%, 50%, ${alpha})`);
    g.addColorStop(0.50, `hsla(135, 100%, 46%, ${alpha})`);
    g.addColorStop(0.66, `hsla(200, 100%, 52%, ${alpha})`);
    g.addColorStop(0.82, `hsla(235, 100%, 56%, ${alpha})`);
    g.addColorStop(1.00, `hsla(270, 100%, 52%, ${alpha})`);
    return g;
  }

  function refreshGradients(){
    // Must be rebuilt when backCtx changes (swap) or on resize
    baseGrad = rainbowGradientAbsolute(1.00);
    hiGrad   = rainbowGradientAbsolute(0.92);
  }

  function swapBuffers(){
    const tmp = front; front = back; back = tmp;
    const tmpC = frontCtx; frontCtx = backCtx; backCtx = tmpC;
    refreshGradients();
  }

  refreshGradients();

  function drawColumnAtX0(vol){
    const midY = H * midYFactor;

    // louder response + tiny when silent
    const vRaw = clamp(vol,0,1);
    const v = Math.pow(vRaw, 0.45); // bigger response
    const ampMax = H * 0.28;
    const amp = (0.02 + v*0.98) * ampMax; // very small at silence

    const y1 = midY - amp;
    const y2 = midY + amp;

    const widthPx = Math.max(1, Math.floor(colW * DPR));
    const spacing = strands <= 1 ? 0 : (widthPx / (strands-1));

    // Base fibers (strong, crisp)
    backCtx.save();
    backCtx.globalCompositeOperation = "source-over";
    backCtx.lineCap = "round";
    backCtx.shadowBlur = 12 * DPR;
    backCtx.shadowColor = "rgba(255,255,255,0.32)";

    for(let i=0;i<strands;i++){
      const t = strands<=1 ? 0.5 : i/(strands-1);
      const dens = Math.exp(-Math.pow((t-0.5)/0.33, 2));
      const a = 0.55 + 0.35*dens; // strong visibility
      const x = i * spacing;

      backCtx.globalAlpha = a;
      backCtx.strokeStyle = baseGrad;
      backCtx.lineWidth = 1.0 * DPR;
      backCtx.beginPath();
      backCtx.moveTo(x, y1);
      backCtx.lineTo(x, y2);
      backCtx.stroke();
    }
    backCtx.restore();

    // Jewel / crystal highlight
    backCtx.save();
    backCtx.globalCompositeOperation = "screen";
    backCtx.shadowBlur = 26 * DPR;
    backCtx.shadowColor = "rgba(255,255,255,0.65)";

    const cx = widthPx * 0.55;

    backCtx.globalAlpha = 0.95;
    backCtx.strokeStyle = hiGrad;
    backCtx.lineWidth = 0.95 * DPR;
    backCtx.beginPath();
    backCtx.moveTo(cx, y1);
    backCtx.lineTo(cx, y2);
    backCtx.stroke();

    backCtx.globalAlpha = 0.38;
    backCtx.strokeStyle = "rgba(255,255,255,0.98)";
    backCtx.lineWidth = 0.65 * DPR;
    backCtx.beginPath();
    backCtx.moveTo(cx - 1.2*DPR, y1 + 1.2*DPR);
    backCtx.lineTo(cx - 1.2*DPR, y2 - 1.2*DPR);
    backCtx.stroke();

    // micro sparkle lines
    backCtx.globalAlpha = 0.22;
    backCtx.strokeStyle = "rgba(255,255,255,0.95)";
    backCtx.lineWidth = 0.35 * DPR;
    backCtx.beginPath();
    backCtx.moveTo(cx + 0.9*DPR, y1 + 2.2*DPR);
    backCtx.lineTo(cx + 0.9*DPR, y2 - 2.2*DPR);
    backCtx.stroke();

    backCtx.globalAlpha = 0.14;
    backCtx.strokeStyle = "rgba(210,245,255,0.95)";
    backCtx.lineWidth = 0.30 * DPR;
    backCtx.beginPath();
    backCtx.moveTo(cx + 2.0*DPR, y1 + 3.0*DPR);
    backCtx.lineTo(cx + 2.0*DPR, y2 - 3.0*DPR);
    backCtx.stroke();

    backCtx.restore();
  }

  // ---------------- Render loop (optimized shift) ----------------
  let last = performance.now();
  let acc = 0;
  let smVol = 0;

  function frame(now){
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    // Always draw background
    ctx.drawImage(bg, 0, 0);

    // Keep sampling audio so resume feels immediate
    const v = computeRMS();
    smVol = lerp(smVol, v, 1 - Math.pow(0.001, dt));

    if(running){
      acc += speed * DPR * dt;
      const stepPx = Math.max(1, Math.floor(colW * DPR));
      const shifts = Math.floor(acc / stepPx);

      if(shifts > 0){
        acc -= shifts * stepPx;

        // Shift front -> back (move right)
        backCtx.setTransform(1,0,0,1,0,0);
        backCtx.clearRect(0,0,W,H);
        backCtx.drawImage(front, shifts*stepPx, 0);

        // Mild persistence (avoid over-bright accumulation)
        backCtx.save();
        backCtx.globalCompositeOperation = "destination-in";
        backCtx.fillStyle = "rgba(255,255,255,0.995)";
        backCtx.fillRect(0,0,W,H);
        backCtx.restore();

        // Draw new columns at left (x = i*stepPx)
        for(let i=0;i<shifts;i++){
          backCtx.save();
          backCtx.translate(i*stepPx, 0);
          drawColumnAtX0(smVol);
          backCtx.restore();
        }

        swapBuffers();
      }
    }

    // Composite wave on top (visible on bright background)
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.drawImage(front, 0, 0);
    ctx.restore();

    // Subtle glass sheen sweep
    const tt = (now*0.00014) % 1;
    const cx = (0.1 + 0.9*tt)*W;
    const w = 0.18*W;
    const sg = ctx.createLinearGradient(cx-w,0,cx+w,0);
    sg.addColorStop(0.00,"rgba(255,255,255,0)");
    sg.addColorStop(0.50,"rgba(255,255,255,0.10)");
    sg.addColorStop(1.00,"rgba(255,255,255,0)");
    ctx.save();
    ctx.globalCompositeOperation="screen";
    ctx.fillStyle = sg;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // UI pill text
    if(!hasStarted){
      pill.textContent = "Press Start";
    }else{
      pill.textContent = running ? "Running · tap to stop" : "Paused · tap to start";
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ---------------- Controls ----------------
  async function doStart(){
    if(hasStarted) return;
    status("마이크 시작 중…");
    try{
      await startMic();
      hasStarted = true;
      running = true;
      ui.style.display = "none";
      // small warm-up to avoid “first frame feels blank”
      requestAnimationFrame(()=>requestAnimationFrame(()=>{}));
    }catch(e){
      showErr(e);
      status("마이크 실패: HTTPS/권한 확인");
    }
  }

  function toggleRun(){
    if(!hasStarted) return;
    running = !running;
  }

  // Start button
  btnStart.addEventListener("click", doStart);

  // Tap anywhere to toggle (after started)
  window.addEventListener("pointerdown", (e) => {
    // prevent toggling when UI is still visible (start screen)
    if(ui.style.display !== "none") return;
    toggleRun();
  }, { passive:true });

})();
</script>
</body>
</html>
