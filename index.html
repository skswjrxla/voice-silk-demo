<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Glass Voice Columns</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#f3f6ff;}
    canvas{display:block;width:100vw;height:100vh;touch-action:manipulation;}
    .ui{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:24px;
      background: radial-gradient(900px 520px at 50% 25%, rgba(255,255,255,.90), rgba(240,244,255,.55));
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:#0f1430;
    }
    .card{
      width:min(560px, 92vw);
      border-radius:22px;
      padding:18px 16px 16px;
      background: rgba(255,255,255,.58);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(40,60,120,.14);
      box-shadow: 0 18px 70px rgba(10,18,40,.14);
      text-align:center;
    }
    .title{margin:0 0 8px;font-size:18px;font-weight:900;letter-spacing:.2px;}
    .desc{margin:0 0 14px;font-size:13px;line-height:1.5;color:rgba(10,18,40,.72);}
    button{
      border:0; cursor:pointer;
      padding:12px 16px;border-radius:14px;
      background: rgba(255,255,255,.72);
      color:#0f1430; font-weight:900;
      border: 1px solid rgba(40,60,120,.16);
      box-shadow: 0 10px 26px rgba(10,18,40,.12);
    }
    button:active{transform: translateY(1px);}
    .badge{
      display:inline-block;margin-top:10px;
      padding:6px 10px;border-radius:999px;
      background: rgba(255,255,255,.66);
      border:1px solid rgba(40,60,120,.14);
      font-size:12px;color:rgba(10,18,40,.70);
    }
    .hint{
      position:fixed;left:12px;top:10px;z-index:5;
      padding:8px 10px;border-radius:999px;
      background: rgba(255,255,255,.64);
      border: 1px solid rgba(40,60,120,.14);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 0 8px 22px rgba(10,18,40,.12);
      font:12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color:rgba(10,18,40,.72);
      user-select:none;
    }
  </style>
</head>
<body>
  <div class="hint">No wobble · Only moving vertical fibers (최적화)</div>
  <canvas id="c"></canvas>

  <div class="ui" id="ui">
    <div class="card">
      <p class="title">Glass Voice Columns</p>
      <p class="desc">
        요동(사인/노이즈) 없이, 세로 섬유 컬럼이 왼→오로 이동합니다.<br/>
        컬럼 길이만 음량에 비례해 커지며, 위=빨강/아래=보라 무지개 그라데이션(선명)입니다.
      </p>
      <button id="btnMic">마이크 시작</button>
      <div class="desc" style="margin-top:10px;">
        마이크는 HTTPS에서 동작합니다. (GitHub Pages OK)
      </div>
      <div class="badge" id="status">대기 중</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const ui = document.getElementById("ui");
  const btnMic = document.getElementById("btnMic");
  const statusEl = document.getElementById("status");
  const status = (t)=>statusEl.textContent=t;

  // ---------- perf knobs ----------
  let DPR = 1;
  let W=0,H=0;

  // background cache
  const bg = document.createElement("canvas");
  const bgx = bg.getContext("2d", { alpha:false });

  // wave buffers (ping-pong)
  let waveA = document.createElement("canvas");
  let waveB = document.createElement("canvas");
  let wA = waveA.getContext("2d", { alpha:true });
  let wB = waveB.getContext("2d", { alpha:true });

  // audio
  let audioCtx=null, analyser=null, source=null, stream=null;
  let dataTime=null;

  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;

  function resize(){
    // 더 부드럽게(렉 방지): DPR cap
    DPR = Math.min(1.5, window.devicePixelRatio || 1);
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = innerWidth+"px";
    canvas.style.height = innerHeight+"px";

    bg.width = W; bg.height = H;
    waveA.width = W; waveA.height = H;
    waveB.width = W; waveB.height = H;

    wA.clearRect(0,0,W,H);
    wB.clearRect(0,0,W,H);

    buildGlassBackground();
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  // ---------- background (light glass, cheap) ----------
  function buildGlassBackground(){
    const g = bgx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#ffffff");
    g.addColorStop(0.45, "#f3f6ff");
    g.addColorStop(1, "#edf2ff");
    bgx.fillStyle = g;
    bgx.fillRect(0,0,W,H);

    // prismatic blobs
    for(let i=0;i<6;i++){
      const cx = (0.12 + Math.random()*0.76)*W;
      const cy = (0.12 + Math.random()*0.76)*H;
      const r  = (0.12 + Math.random()*0.18)*Math.min(W,H);
      const rg = bgx.createRadialGradient(cx,cy,r*0.15, cx,cy,r);
      rg.addColorStop(0.00, "rgba(255,255,255,0.55)");
      rg.addColorStop(0.30, "rgba(210,240,255,0.20)");
      rg.addColorStop(0.55, "rgba(235,220,255,0.15)");
      rg.addColorStop(0.75, "rgba(255,225,235,0.11)");
      rg.addColorStop(1.00, "rgba(255,255,255,0.0)");
      bgx.save();
      bgx.globalCompositeOperation = "screen";
      bgx.fillStyle = rg;
      bgx.beginPath();
      bgx.ellipse(cx,cy,r*1.15,r*0.78, Math.random()*Math.PI, 0, Math.PI*2);
      bgx.fill();
      bgx.restore();
    }

    // frosted grain tile
    const tile = document.createElement("canvas");
    tile.width = 96; tile.height = 96;
    const tctx = tile.getContext("2d", { alpha:true });
    const img = tctx.createImageData(96,96);
    const d = img.data;
    for(let i=0;i<d.length;i+=4){
      const v = 245 + ((Math.random()*18)|0) - 9;
      d[i]=v; d[i+1]=v; d[i+2]=v;
      d[i+3]=14 + ((Math.random()*22)|0);
    }
    tctx.putImageData(img,0,0);

    const pat = bgx.createPattern(tile, "repeat");
    bgx.save();
    bgx.globalCompositeOperation = "soft-light";
    bgx.globalAlpha = 0.22;
    bgx.fillStyle = pat;
    bgx.fillRect(0,0,W,H);
    bgx.restore();

    const vg = bgx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.35, W/2,H/2, Math.max(W,H)*0.98);
    vg.addColorStop(0, "rgba(255,255,255,0)");
    vg.addColorStop(1, "rgba(20,35,90,0.08)");
    bgx.fillStyle = vg;
    bgx.fillRect(0,0,W,H);
  }

  // ---------- audio (RMS only) ----------
  async function startMic(){
    status("마이크 요청 중…");
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    await audioCtx.resume();

    stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
    });

    source = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;              // light
    analyser.smoothingTimeConstant = 0.85;
    source.connect(analyser);

    dataTime = new Uint8Array(analyser.fftSize);
    status("마이크 연결됨");
  }

  function computeRMS(){
    if(!analyser || !dataTime) return 0;
    analyser.getByteTimeDomainData(dataTime);
    let sum = 0;
    for(let i=0;i<dataTime.length;i++){
      const v = (dataTime[i]-128)/128;
      sum += v*v;
    }
    return clamp(Math.sqrt(sum/dataTime.length), 0, 1);
  }

  // ---------- columns model (NO WOBBLE) ----------
  const midYFactor = 0.54;      // 고정 중심선
  const speed = 420;            // px/sec (이동 속도)
  const colW = 6;               // 컬럼 폭(작을수록 촘촘)
  const strands = 7;            // 컬럼 안 세로섬유 개수(가벼우면서 선명)

  // 더 진하고 선명한 유리 무지개 (위 red -> 아래 violet)
  function rainbowGradient(y1,y2, alpha){
    const g = wB.createLinearGradient(0,y1,0,y2);
    // saturation/brightness up
    g.addColorStop(0.00, `hsla(0,   100%, 58%, ${alpha})`);  // red
    g.addColorStop(0.16, `hsla(30,  100%, 58%, ${alpha})`);  // orange
    g.addColorStop(0.33, `hsla(55,  100%, 56%, ${alpha})`);  // yellow
    g.addColorStop(0.50, `hsla(135, 95%, 54%, ${alpha})`);   // green
    g.addColorStop(0.66, `hsla(200, 98%, 56%, ${alpha})`);   // cyan/blue
    g.addColorStop(0.82, `hsla(235, 98%, 58%, ${alpha})`);   // blue
    g.addColorStop(1.00, `hsla(270, 98%, 58%, ${alpha})`);   // violet
    return g;
  }

  // “세로 섬유” 컬럼 한 개를 x=0에 그린다.
  // 요동 없음: y1,y2는 오직 amp로만 결정.
  function drawColumn(vol){
    const midY = H * midYFactor;

    // 볼륨 -> 길이 (원하는 반응성 위해 약간 곡선)
    const v = Math.pow(clamp(vol,0,1), 0.65); // 작은 소리도 보이게
    const ampMax = H * 0.28;
    const amp = (0.03 + v*0.97) * ampMax;

    const y1 = midY - amp;
    const y2 = midY + amp;

    // base + highlight gradients (stronger)
    const base = rainbowGradient(y1,y2, 0.85);
    const hi   = rainbowGradient(y1,y2, 0.55);

    const widthPx = Math.max(1, Math.floor(colW * DPR));
    const spacing = strands <= 1 ? 0 : (widthPx / (strands-1));

    // base fibers
    wB.save();
    wB.globalCompositeOperation = "source-over";
    wB.lineCap = "round";
    wB.shadowBlur = 12 * DPR;
    wB.shadowColor = "rgba(255,255,255,0.28)";

    for(let i=0;i<strands;i++){
      const t = strands<=1 ? 0.5 : i/(strands-1);
      // 가운데가 가장 진하게 (섬유 다발 느낌)
      const dens = Math.exp(-Math.pow((t-0.5)/0.33, 2));
      const a = 0.22 + 0.28*dens; // 더 진하게
      const x = i * spacing;

      wB.globalAlpha = a;
      wB.strokeStyle = base;
      wB.lineWidth = 1.0 * DPR;

      wB.beginPath();
      wB.moveTo(x, y1);
      wB.lineTo(x, y2);
      wB.stroke();
    }
    wB.restore();

    // glass spec highlight (screen)
    wB.save();
    wB.globalCompositeOperation = "screen";
    wB.shadowBlur = 18 * DPR;
    wB.shadowColor = "rgba(255,255,255,0.40)";

    const cx = widthPx * 0.55;
    wB.globalAlpha = 0.95;
    wB.strokeStyle = hi;
    wB.lineWidth = 0.95 * DPR;
    wB.beginPath();
    wB.moveTo(cx, y1);
    wB.lineTo(cx, y2);
    wB.stroke();

    // extra white spec line (strong + crisp)
    wB.globalAlpha = 0.35;
    wB.strokeStyle = "rgba(255,255,255,0.95)";
    wB.lineWidth = 0.65 * DPR;
    wB.beginPath();
    wB.moveTo(cx - 1.2*DPR, y1 + 1.2*DPR);
    wB.lineTo(cx - 1.2*DPR, y2 - 1.2*DPR);
    wB.stroke();

    wB.restore();
  }

  // shift 방식 (최적화 핵심)
  let last = performance.now();
  let acc = 0;
  let smVol = 0;

  function frame(now){
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    // draw background once per frame
    ctx.drawImage(bg,0,0);

    // volume smoothing (요동 X, 단지 길이 변화만 부드럽게)
    const v = computeRMS();
    smVol = lerp(smVol, v, 1 - Math.pow(0.001, dt));

    // move right by shifting the wave buffer
    acc += speed * DPR * dt;

    const stepPx = Math.max(1, Math.floor(colW * DPR));
    const shifts = Math.floor(acc / stepPx);

    if(shifts > 0){
      acc -= shifts * stepPx;

      // copy A -> B shifted right
      wB.setTransform(1,0,0,1,0,0);
      wB.clearRect(0,0,W,H);
      wB.drawImage(waveA, shifts*stepPx, 0);

      // slight fade to avoid over-bright accumulation
      wB.save();
      wB.globalCompositeOperation = "destination-in";
      wB.fillStyle = "rgba(255,255,255,0.985)";
      wB.fillRect(0,0,W,H);
      wB.restore();

      // draw N new columns at the left edge (x in [0..stepPx*(shifts-1)])
      // IMPORTANT: still no “wobble”; only length changes.
      for(let i=0;i<shifts;i++){
        wB.save();
        wB.translate(i*stepPx, 0);
        drawColumn(smVol);
        wB.restore();
      }

      // swap buffers
      const t = waveA; waveA = waveB; waveB = t;
      wA = waveA.getContext("2d", { alpha:true });
      wB = waveB.getContext("2d", { alpha:true });
    }

    // composite wave over background
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.drawImage(waveA, 0, 0);
    ctx.restore();

    // subtle sheen sweep (optional, cheap)
    const tt = (now*0.00014) % 1;
    const cx = (0.1 + 0.9*tt)*W;
    const w = 0.18*W;
    const sg = ctx.createLinearGradient(cx-w,0,cx+w,0);
    sg.addColorStop(0.00,"rgba(255,255,255,0)");
    sg.addColorStop(0.50,"rgba(255,255,255,0.10)");
    sg.addColorStop(1.00,"rgba(255,255,255,0)");
    ctx.save();
    ctx.globalCompositeOperation="screen";
    ctx.fillStyle = sg;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // UI
  btnMic.addEventListener("click", async () => {
    try{
      status("마이크 시작 중…");
      await startMic();
      ui.style.display = "none";
    }catch(e){
      console.error(e);
      status("마이크 실패: HTTPS/권한 확인");
    }
  });

})();
</script>
</body>
</html>
